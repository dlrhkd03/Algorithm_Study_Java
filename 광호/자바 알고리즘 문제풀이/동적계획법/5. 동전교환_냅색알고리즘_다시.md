# 5. 동전교환(냅색 알고리즘)

설명

다음과 같이 여러 단위의 동전들이 주어져 있을때 거스름돈을 가장 적은 수의 동전으로 교환해주려면 어떻게 주면 되는가?

각 단위의 동전은 무한정 쓸 수 있다.



입력

첫 번째 줄에는 동전의 종류개수 N(1<=N<=50)이 주어진다.

두 번째 줄에는 N개의 동전의 종류가 주어지고, 그 다음줄에 거슬러 줄 금액 M(1<=M<=500)이 주어진다.

각 동전의 종류는 100원을 넘지 않는다.



출력

첫 번째 줄에 거슬러 줄 동전의 최소개수를 출력한다.



예시 입력 1 

```
3
1 2 5
15
```

예시 출력 1

```
3
```



## 접근방법

냅색 알고리즘이 dfs로 알고있어서 dfs로 풀었다. 그러나 시간초과가 났다.

동전 종류가 12개정도까지는 dfs로 가능하나, 50개까지 늘어난 상황에서는 시간초과가 난다고 한다.

냅색 알고리즘에 대해 알아보자.

* dfs로 푼 코드

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    static int N, M, minCnt = Integer.MAX_VALUE;
    static int[] token;

    static void solution() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        token = new int[N];

        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        for (int i = 0; i < N; i++) {
            token[i] = Integer.parseInt(st.nextToken());
        }

        M = Integer.parseInt(br.readLine());
    }

    static void rec_function(int k, int L) {
        if (minCnt < L) return;
        if (k <= 0) {
            if (k == 0) minCnt = L;
            return;
        }

        for (int i = 0; i < N; i++) {
            rec_function(k - token[i], L + 1);
        }
    }

    public static void main(String[] args) throws IOException {
        solution();
        rec_function(M, 0);
        System.out.println(minCnt);
    }
}
~~~



## 냅색 알고리즘

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    static int N, M;
    static int[] token, coins;

    static void solution() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        token = new int[N];
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        for (int i = 0; i < N; i++) {
            token[i] = Integer.parseInt(st.nextToken());
        }

        M = Integer.parseInt(br.readLine());
        coins = new int[M + 1];
        for (int i = 0; i <= M; i++) coins[i] = i;

        for (int i = 0; i < N; i++) {
            for (int j = token[i]; j <= M; j++) {
                coins[j] = Math.min(coins[j - token[i]] + 1, coins[j]);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        solution();
        System.out.println(coins[M]);
    }
}
```

